function [aw, sw] = width_from_mask(I, cl, spacing)

% Computes average channel width for segments of centerline. First, 
% segments are computed based on the input spacing variable. Then for each 
% segment, the length is computed. The channel area of each segment is then
% computed using a buffer polygon. The average width of the segment is then 
% simply the segment area / segment length. 

% Requires the Image Processing toolbox (poly2mask command)

% INPUTS:      I - binary image of river (river mask)
%             cl - Nx2 array of x,y centerline coordinates
%        spacing - can either be a single number or a vector. If a single
%                  nuber is passed, it represents the along-centerline
%                  distance at which the average channel width is computed.
%                  If a vector is passed, it should contain the breakpoints
%                  along the centerline that demarcate segment endpoints to
%                  compute channel width.

% OUTPUTS:   aw - average channel width at each segment
%            sw - downstream distance of middle of each segment

% keyboard

% Parameterizing centerline by along-stream distance
dists = sqrt(diff(cl(:,1)).^2+diff(cl(:,2)).^2); % distances between each centerline node
cumdists = [0; cumsum(dists)]; % cumulative distance along centerline
len = cumdists(end); % total centerline length

% Compute average reach width for smoothing window and sizing buffer
acw = sum(sum(I))/len;

% Smooth the centerline 
cls = savfilt(cl,acw*2);

% Break the channel into segments
ncl = length(cl);
if numel(spacing) == 1
    bkpts = [1:spacing:ncl]';
    % Last breakpoint should be last point along centerline
    if bkpts(end) < ncl
        bkpts = [bkpts; ncl];
    end
else
    bkpts = spacing;
end

% Initialize storage
aw = zeros(numel(bkpts)-1,1);
sw = aw;

% Set the threhold distance to filter unwanted blobs generated by the
% buffer. This distance represents the along-centerline distance from the
% blob's centroid to the midpoint of the segment being analyzed.
centroid_threshold = len/numel(bkpts)/1.5; 

% Cycle through all segments and remove unwanted blobs then compute average
% width of the segment
for i = 1:numel(bkpts)-1
      
    % Compute length of segment
    seglen = cumdists(bkpts(i+1)) - cumdists(bkpts(i));
    
    % Compute river area of segment
    % Make buffer around segment of water mask 
    Ibuffer = buffer_for_width(cls, [bkpts(i) bkpts(i+1)], 2*acw, size(I));
    
    % Ensure that the buffer only captures the part of the river we're
    % interested in (sometimes if the river doubles back on itself it picks
    % up area from the doubled-back part) by thresholding the distance from
    % each blob's centroid to the midpoint of the centerline segment.
    segarea_try = Ibuffer & I;
    CC = bwconncomp(segarea_try);
    if CC.NumObjects > 1 % if we have more than one blob
        S = regionprops(CC,'Centroid','PixelIdxList');

        % Find (roughly) middle node along centerline segment
        mid_dist =  seglen/2 + cumdists(bkpts(i));
        [mid_idx, ~] = find(cumdists - mid_dist > 0, 1, 'first'); % find index of middle centerline node
        clmid = cl(mid_idx,:); % get x,y coordinates for distance calc
        
        % Find closest centerline node to each centroid
        md_idx = [];
        for ii = 1:CC.NumObjects
            [~, md_idx(ii)] = min(sqrt((S(ii).Centroid(1)-cl(:,1)).^2 + (S(ii).Centroid(2)-cl(:,2)).^2));
        end
        
        % Compute the along-stream distance from each centroid to
        % middle node along centerline
        cent2cldist = abs(cumdists(mid_idx) - cumdists(md_idx));
        
        % Keep the blobs that are close enough (in most cases will result
        % in a single kept blob)
        keepblob = find(cent2cldist < centroid_threshold);
        Ibuffer = false(size(I));
        for jj = 1:numel(keepblob)
            Ibuffer(S(keepblob(jj)).PixelIdxList) = true;
        end
        segarea = sum(sum(Ibuffer & I));
    else        
        segarea = sum(sum(segarea_try));
    end
    
    % Compute average width of segment
    aw(i) = segarea/seglen;
    
    % Compute streamwise coordinate of center of segment
    sw(i) = (cumdists(bkpts(i)) + cumdists(bkpts(i+1)))/2;
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                          buffer_for_width                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function Ibuffer = buffer_for_width(cl, idcs, bufwid, imsize)

% keyboard

% Generates a binary mask buffering a centerline between two nodes. 
% Can fail in very high-curvature regions; if this happens, decrease the
% buffer width. Method simply finds vectors perpendicular to centerline 
% based on the channel angle.

% INPUTS:      cl - Nx2 array of x,y centerline coordinates
%              idcs - Nx2 array; first elements are upstream index to start
%                     buffer, second elements are downstream index to stop
%                     buffer
%              W  - average channel width (used to set buffer width)
%              imsize - size of image over which mask will be used
%              
% OUTPUTS:     BW_buffer - binary image of size imsize with buffer pixels
%                          equal to 1 and all other pixels 0

Xs = cl(:,1);
Ys = cl(:,2);

% First angle is unknown, set to NaN
A = angles(cl);

Ibuffer = false(imsize);
for i = 1:size(idcs,1)
    
    % Find buffer extents
    Xl = Xs(idcs(i,1):idcs(i,2))-sin(pi-A(idcs(i,1):idcs(i,2)))*bufwid;
    Yl = Ys(idcs(i,1):idcs(i,2))-cos(pi-A(idcs(i,1):idcs(i,2)))*bufwid; 
    Xr = Xs(idcs(i,1):idcs(i,2))+sin(pi-A(idcs(i,1):idcs(i,2)))*bufwid;
    Yr = Ys(idcs(i,1):idcs(i,2))+cos(pi-A(idcs(i,1):idcs(i,2)))*bufwid; 

    % Make a polygon using buffer extents
    poly_clip = [[Xl; flipud(Xr); Xl(1)] [Yl; flipud(Yr); Yl(1)]];
    poly_clip = poly_clip(~isnan(poly_clip(:,1)),:);

    % Create buffer raster from the polygon
    tempbuff = poly2mask(poly_clip(:,1),poly_clip(:,2), imsize(1), imsize(2));
    % Remove part of buffer where segment lines intersect
    CC = bwconncomp(tempbuff);
    numPixels = cellfun(@numel,CC.PixelIdxList);
    [~,idx] = max(numPixels);
    % Make the binary buffer image
    Ibuffer(CC.PixelIdxList{idx}) = true;
end

