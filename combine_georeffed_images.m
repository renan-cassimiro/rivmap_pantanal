function [Im_out,Georef_out] = combine_georeffed_images(Im,Georef)

% This code stitches together images or vector centerlines using their
% georef information.

% INPUTS:  
%             Im - an N-element cell, where N is the number of images to be
%                  stitched together. Im can be populated by either images
%                  or Mx2 x,y centerline coordinates.
%         Georef - an N-element cell that holds the georeferencing
%                  information (generated by either geotiffread or 
%                  maprasterref) 

% OUTPUTS: 
%       combined - the combined image or set of vectors

% keyboard

% Determine whether input is image or x,y centerline
if min(size(Im{1})) == 2 % If input is x,y centerline
    
    % Adjust the x,y coordinates
    for i = 1:numel(Im)
        cl{i} = Im{i};
        Imadj(i,1) = -Georef{i}.XWorldLimits(1)/Georef{i}.CellExtentInWorldX;
        Imadj(i,2) = Georef{i}.YWorldLimits(2)/Georef{i}.CellExtentInWorldY;
        cla{i} = [cl{i}(:,1)-Imadj(i,1), cl{i}(:,2)-Imadj(i,2)];
    end
       
    % Stitch the new coordinates together by starting with the first cl and
    % appending other segments according to which one has the closest
    % endpoint to one of the two endpoints of the growing cl; remove the cl
    % pieces from cla cell as they are added to clall; stop when there are
    % no pieces left.
    clall = cla{1};
    cla(1) = [];
    while isempty(cla) == 0
        for i = 1:numel(cla)
            clspt = clall(1,:);
            clept = clall(end,:);
            cl2spt = cla{i}(1,:);
            cl2ept = cla{i}(end,:);

            dist(i,1)= sqrt(sum((clspt-cl2spt).^2));
            dist(i,2) = sqrt(sum((clspt-cl2ept).^2));
            dist(i,3) = sqrt(sum((clept-cl2spt).^2));
            dist(i,4) = sqrt(sum((clept-cl2ept).^2)); 
        end
        [~,I] = min(dist(:));
        [I_row, I_col] = ind2sub(size(dist),I);
        if I_col == 1
            clall = [flipud(cla{I_row}); clall];
        elseif I_col == 2
            clall = [cla{I_row}; clall];
        elseif I_col == 3
            clall = [clall; cla{I_row}];
        elseif I_col == 4
            clall = [clall; flipud(cla{I_row})];
        end
        cla(I_row) = [];
    end
    Im_out = clall;
    Georef_out = []; % no georef needed for new cl



else % The input is images
   
    for i = 1:numel(Georef)
        if Georef{1}.CellExtentInWorldX ~= Georef{i}.CellExtentInWorldX  ...
            || Georef{1}.CellExtentInWorldY ~= Georef{i}.CellExtentInWorldY
            error('Pixel sizes are different. Exiting.')
            return
        end
    end
    % Create empty matrix to paste in images
    pixelsizex = Georef{1}.CellExtentInWorldX;
    pixelsizey = Georef{1}.CellExtentInWorldY;
    for i = 1:numel(Georef)
        xlims(i,:) = Georef{i}.XWorldLimits;    
        ylims(i,:) = -Georef{i}.YWorldLimits;
    end
    xmax = max(xlims(:)); xmin = min(xlims(:));  
    ymax = max(ylims(:)); ymin = min(ylims(:));

    xsize = (xmax-xmin)/pixelsizex + 1;
    ysize = (ymax-ymin)/pixelsizey;

    % Create georeferencing for the combined image
    Georef_out = maprasterref('RasterSize', [ysize, xsize], ...
              'YWorldLimits', [-ymax -ymin], 'ColumnsStartFrom','north', ...
              'XWorldLimits', [xmin xmax+30]);

    % Fill in empty matrix with images
    geoXur = Georef_out.XWorldLimits(1);
    geoYur = Georef_out.YWorldLimits(2);
    Im_out = nan(Georef_out.RasterSize);
    for i = 1:numel(Georef)
        xidcs = (Georef{i}.XWorldLimits(:) - geoXur)/Georef{i}.CellExtentInWorldX;
        yidcs = sort(abs((Georef{i}.YWorldLimits(:) - geoYur)/Georef{i}.CellExtentInWorldY));
        Im_out(yidcs(1)+1:yidcs(2),xidcs(1)+1:xidcs(2)) = Im{i};
    end

end
